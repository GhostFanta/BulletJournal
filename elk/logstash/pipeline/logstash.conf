input{
	jdbc {
        	# Postgres jdbc connection string to our database, mydb
        	jdbc_connection_string => "jdbc:postgresql://${postgres_hostname}:5432/postgres"
        	# The user we wish to execute our statement as
        	jdbc_user => "postgres"
		  	jdbc_password => "docker"
        	# The path to our downloaded jdbc driver
        	jdbc_driver_library => "${postgres_jdbc_driver_absolute_path}"
			last_run_metadata_path => "${logstash_last_run_metadata_absolute_path}"
        	# The name of the driver class for Postgresql
        	jdbc_driver_class => "org.postgresql.Driver"
			jdbc_paging_enabled => true
			#tracking update time
			tracking_column => "unix_ts_in_secs"
			use_column_value => true
			tracking_column_type => "numeric"
			schedule => "*/5 * * * * *"
			type => "note"
	        # DB query
	        statement => "SELECT notes.id,notes.name AS value,projects.group_id,Extract(epoch FROM notes.updated_at) AS unix_ts_in_secs FROM notes LEFT JOIN projects ON notes.project_id = projects.id WHERE  (Extract(epoch FROM notes.updated_at) > :sql_last_value AND notes.updated_at < now() at time zone 'utc') ORDER  BY notes.updated_at ASC"
	}

	jdbc {
	        # Postgres jdbc connection string to our database, mydb
	        jdbc_connection_string => "jdbc:postgresql://${postgres_hostname}:5432/postgres"
	        # The user we wish to execute our statement as
	        jdbc_user => "postgres"
			jdbc_password => "docker"
	        # The path to our downloaded jdbc driver
	        jdbc_driver_library => "${postgres_jdbc_driver_absolute_path}"
			last_run_metadata_path => "${logstash_last_run_metadata_absolute_path}"
	        # The name of the driver class for Postgresql
	        jdbc_driver_class => "org.postgresql.Driver"
			jdbc_paging_enabled => true
			#tracking update time
			tracking_column => "unix_ts_in_secs"
			use_column_value => true
			tracking_column_type => "numeric"
			schedule => "*/5 * * * * *"
			type => "transaction"
	        # DB query
	        statement => "SELECT transactions.id,transactions.name AS value,projects.group_id,Extract(epoch FROM transactions.updated_at) AS unix_ts_in_secs FROM transactions LEFT JOIN projects ON transactions.project_id = projects.id WHERE  (Extract(epoch FROM transactions.updated_at) > :sql_last_value AND transactions.updated_at < now() at time zone 'utc' )ORDER BY transactions.updated_at ASC"
	}

	jdbc {
        	# Postgres jdbc connection string to our database, mydb
        	jdbc_connection_string => "jdbc:postgresql://${postgres_hostname}:5432/postgres"
	        # The user we wish to execute our statement as
	        jdbc_user => "postgres"
			jdbc_password => "docker"
	        # The path to our downloaded jdbc driver
	        jdbc_driver_library => "${postgres_jdbc_driver_absolute_path}"
			last_run_metadata_path => "${logstash_last_run_metadata_absolute_path}"
	        # The name of the driver class for Postgresql
	        jdbc_driver_class => "org.postgresql.Driver"
			jdbc_paging_enabled => true
			#tracking update time
			tracking_column => "unix_ts_in_secs"
			use_column_value => true
			tracking_column_type => "numeric"
			schedule => "*/5 * * * * *"
			type => "task"
	        # DB query
	        statement =>"SELECT tasks.id ,tasks.name As value,projects.group_id,Extract(epoch FROM tasks.updated_at) AS unix_ts_in_secs FROM tasks LEFT JOIN projects ON tasks.project_id = projects.id WHERE  (Extract(epoch FROM tasks.updated_at) > :sql_last_value AND tasks.updated_at < now() at time zone 'utc' ) ORDER  BY tasks.updated_at ASC"
    }
	jdbc {
        	# Postgres jdbc connection string to our database, mydb
        	jdbc_connection_string => "jdbc:postgresql://${postgres_hostname}:5432/postgres"
	        # The user we wish to execute our statement as
	        jdbc_user => "postgres"
			jdbc_password => "docker"
	        # The path to our downloaded jdbc driver
	        jdbc_driver_library => "${postgres_jdbc_driver_absolute_path}"
			last_run_metadata_path => "${logstash_last_run_metadata_absolute_path}"
	        # The name of the driver class for Postgresql
	        jdbc_driver_class => "org.postgresql.Driver"
			jdbc_paging_enabled => true
			#tracking update time
			tracking_column => "unix_ts_in_secs"
			use_column_value => true
			tracking_column_type => "numeric"
			schedule => "*/5 * * * * *"
			type => "note_content"
	        # DB query
	        statement =>"SELECT note_contents.id, note_contents.text AS value, note_contents.note_id AS parent_id, projects.group_id, Extract(epoch FROM note_contents.updated_at) AS unix_ts_in_secs FROM note_contents LEFT JOIN notes ON note_contents.note_id = notes.id LEFT JOIN projects ON notes.project_id = projects.id WHERE ( Extract(epoch FROM note_contents.updated_at) > :sql_last_value AND note_contents.updated_at < Now() at time zone 'utc' ) ORDER BY note_contents.updated_at ASC"
    }
	jdbc {
        	# Postgres jdbc connection string to our database, mydb
        	jdbc_connection_string => "jdbc:postgresql://${postgres_hostname}:5432/postgres"
	        # The user we wish to execute our statement as
	        jdbc_user => "postgres"
			jdbc_password => "docker"
	        # The path to our downloaded jdbc driver
	        jdbc_driver_library => "${postgres_jdbc_driver_absolute_path}"
			last_run_metadata_path => "${logstash_last_run_metadata_absolute_path}"
	        # The name of the driver class for Postgresql
	        jdbc_driver_class => "org.postgresql.Driver"
			jdbc_paging_enabled => true
			#tracking update time
			tracking_column => "unix_ts_in_secs"
			use_column_value => true
			tracking_column_type => "numeric"
			schedule => "*/5 * * * * *"
			type => "task_content"
	        # DB query
	        statement =>"SELECT task_contents.id, task_contents.text AS value, task_contents.task_id AS parent_id, projects.group_id, Extract(epoch FROM task_contents.updated_at) AS unix_ts_in_secs FROM task_contents LEFT JOIN tasks ON task_contents.task_id = tasks.id LEFT JOIN projects ON tasks.project_id = projects.id WHERE ( Extract(epoch FROM task_contents.updated_at) > :sql_last_value AND task_contents.updated_at < Now() at time zone 'utc' ) ORDER BY task_contents.updated_at ASC"
    }
	jdbc {
        	# Postgres jdbc connection string to our database, mydb
        	jdbc_connection_string => "jdbc:postgresql://${postgres_hostname}:5432/postgres"
	        # The user we wish to execute our statement as
	        jdbc_user => "postgres"
			jdbc_password => "docker"
	        # The path to our downloaded jdbc driver
	        jdbc_driver_library => "${postgres_jdbc_driver_absolute_path}"
			last_run_metadata_path => "${logstash_last_run_metadata_absolute_path}"
	        # The name of the driver class for Postgresql
	        jdbc_driver_class => "org.postgresql.Driver"
			jdbc_paging_enabled => true
			#tracking update time
			tracking_column => "unix_ts_in_secs"
			use_column_value => true
			tracking_column_type => "numeric"
			schedule => "*/5 * * * * *"
			type => "transaction_content"
	        # DB query
	        statement =>"SELECT transaction_contents.id, transaction_contents.text AS value, transaction_contents.transaction_id AS parent_id, projects.group_id, Extract(epoch FROM transaction_contents.updated_at) AS unix_ts_in_secs FROM transaction_contents LEFT JOIN transactions ON transaction_contents.transaction_id = transactions.id LEFT JOIN projects ON transactions.project_id = projects.id WHERE ( Extract(epoch FROM transaction_contents.updated_at) > :sql_last_value AND transaction_contents.updated_at < Now() at time zone 'utc' ) ORDER BY transaction_contents.updated_at ASC"
    }
}

filter {
	if [type] == "note" {
        	mutate {
			replace => {"id" => "note@%{[id]}"}
			copy => { "id" => "[@metadata][_id]"}
			remove_field => ["@version", "unix_ts_in_secs"]
		}
	}

	if [type] == "transaction" {
		mutate {
			replace => {"id" => "transaction@%{[id]}"}
			copy => { "id" => "[@metadata][_id]"}
			remove_field => ["@version", "unix_ts_in_secs"]
		}
	}
	if [type] == "task" {
        	mutate {
			replace => {"id" => "task@%{[id]}"}
			copy => { "id" => "[@metadata][_id]"}
			remove_field => ["@version", "unix_ts_in_secs"]
		}
	}
	if [type] == "note_content" {
        	mutate {
			replace => {"id" => "note_content@%{[id]}"}
			replace => {"parent_id" => "note@%{[parent_id]}"}
			copy => { "id" => "[@metadata][_id]"}
			remove_field => ["@version", "unix_ts_in_secs"]
		}
	}
	if [type] == "task_content" {
        	mutate {
			replace => {"id" => "task_content@%{[id]}"}
			replace => {"parent_id" => "task@%{[parent_id]}"}
			copy => { "id" => "[@metadata][_id]"}
			remove_field => ["@version", "unix_ts_in_secs"]
		}
	}
	if [type] == "transaction_content" {
        	mutate {
			replace => {"id" => "transaction_content@%{[id]}"}
			replace => {"parent_id" => "transaction@%{[parent_id]}"}
			copy => { "id" => "[@metadata][_id]"}
			remove_field => ["@version", "unix_ts_in_secs"]
		}
	}
}

output {
	stdout { codec => json_lines }
	elasticsearch {
		hosts => "${elasticsearch_hostname}:9200"
		user => "elastic"
		password => "changeme"
		index => "project_items"
		document_id => "%{[@metadata][_id]}"
  	}
}


